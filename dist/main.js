/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n\n\n//# sourceURL=webpack://demo-vcf/./node_modules/path-browserify/index.js?");

/***/ }),

/***/ "./node_modules/vcards-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/vcards-js/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/********************************************************************************\n    vCards-js, Eric J Nesser, November 2014\n********************************************************************************/\n/*jslint node: true */\n\n\n/**\n * Represents a contact that can be imported into Outlook, iOS, Mac OS, Android devices, and more\n */\nvar vCard = (function () {\n    /**\n     * Get photo object for storing photos in vCards\n     */\n    function getPhoto() {\n        return {\n            url: '',\n            mediaType: '',\n            base64: false,\n\n            /**\n             * Attach a photo from a URL\n             * @param  {string} url       URL where photo can be found\n             * @param  {string} mediaType Media type of photo (JPEG, PNG, GIF)\n             */\n            attachFromUrl: function(url, mediaType) {\n                this.url = url;\n                this.mediaType = mediaType;\n                this.base64 = false;\n            },\n\n            /**\n             * Embed a photo from a file using base-64 encoding (not implemented yet)\n             * @param  {string} filename\n             */\n            embedFromFile: function(fileLocation) {\n              var fs   = __webpack_require__(/*! fs */ \"?1216\");\n              var path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n              this.mediaType = path.extname(fileLocation).toUpperCase().replace(/\\./g, \"\");\n              var imgData = fs.readFileSync(fileLocation);\n              this.url = imgData.toString('base64');\n              this.base64 = true;\n            },\n\n            /**\n             * Embed a photo from a base-64 string\n             * @param  {string} base64String\n             */\n            embedFromString: function(base64String, mediaType) {\n              this.mediaType = mediaType;\n              this.url = base64String;\n              this.base64 = true;\n            }\n        };\n    }\n\n    /**\n     * Get a mailing address to attach to a vCard.\n     */\n    function getMailingAddress() {\n        return {\n            /**\n             * Represents the actual text that should be put on the mailing label when delivering a physical package\n             * @type {String}\n             */\n            label: '',\n\n            /**\n             * Street address\n             * @type {String}\n             */\n            street: '',\n\n            /**\n             * City\n             * @type {String}\n             */\n            city: '',\n\n            /**\n             * State or province\n             * @type {String}\n             */\n            stateProvince: '',\n\n            /**\n             * Postal code\n             * @type {String}\n             */\n            postalCode: '',\n\n            /**\n             * Country or region\n             * @type {String}\n             */\n            countryRegion: ''\n        };\n    }\n\n    /**\n     * Get social media URLs\n     * @return {object} Social media URL hash group\n     */\n    function getSocialUrls() {\n        return {\n            'facebook': '',\n            'linkedIn': '',\n            'twitter': '',\n            'flickr': ''\n        };\n    }\n\n    /********************************************************************************\n     * Public interface for vCard\n     ********************************************************************************/\n    return {\n\n        /**\n         * Specifies a value that represents a persistent, globally unique identifier associated with the vCard\n         * @type {String}\n         */\n        uid: '',\n\n        /**\n         * Date of birth\n         * @type {Datetime}\n         */\n        birthday: '',\n\n        /**\n         * Cell phone number\n         * @type {String}\n         */\n        cellPhone: '',\n\n        /**\n         * Other cell phone number or pager\n         * @type {String}\n         */\n        pagerPhone: '',\n\n        /**\n         * The address for private electronic mail communication\n         * @type {String}\n         */\n        email: '',\n\n        /**\n         * The address for work-related electronic mail communication\n         * @type {String}\n         */\n        workEmail: '',\n\n        /**\n         * First name\n         * @type {String}\n         */\n        firstName: '',\n\n        /**\n         * Formatted name string associated with the vCard object (will automatically populate if not set)\n         * @type {String}\n         */\n        formattedName: '',\n\n        /**\n         * Gender.\n         * @type {String} Must be M or F for Male or Female\n         */\n        gender: '',\n\n        /**\n         * Home mailing address\n         * @type {object}\n         */\n        homeAddress: getMailingAddress(),\n\n        /**\n         * Home phone\n         * @type {String}\n         */\n        homePhone: '',\n\n        /**\n         * Home facsimile\n         * @type {String}\n         */\n        homeFax: '',\n\n        /**\n         * Last name\n         * @type {String}\n         */\n        lastName: '',\n\n        /**\n         * Logo\n         * @type {object}\n         */\n        logo: getPhoto(),\n\n        /**\n         * Middle name\n         * @type {String}\n         */\n        middleName: '',\n\n        /**\n         * Prefix for individual's name\n         * @type {String}\n         */\n        namePrefix: '',\n\n        /**\n         * Suffix for individual's name\n         * @type {String}\n         */\n        nameSuffix: '',\n\n        /**\n         * Nickname of individual\n         * @type {String}\n         */\n        nickname: '',\n\n        /**\n         * Specifies supplemental information or a comment that is associated with the vCard\n         * @type {String}\n         */\n        note: '',\n\n        /**\n         * The name and optionally the unit(s) of the organization associated with the vCard object\n         * @type {String}\n         */\n        organization: '',\n\n        /**\n         * Individual's photo\n         * @type {object}\n         */\n        photo: getPhoto(),\n\n        /**\n         * The role, occupation, or business category of the vCard object within an organization\n         * @type {String}\n         */\n        role: '',\n\n        /**\n         * Social URLs attached to the vCard object (ex: Facebook, Twitter, LinkedIn)\n         * @type {String}\n         */\n        socialUrls: getSocialUrls(),\n\n        /**\n         * A URL that can be used to get the latest version of this vCard\n         * @type {String}\n         */\n        source: '',\n\n        /**\n         * Specifies the job title, functional position or function of the individual within an organization\n         * @type {String}\n         */\n        title: '',\n\n        /**\n         * URL pointing to a website that represents the person in some way\n         * @type {String}\n         */\n        url: '',\n\n        /**\n         * URL pointing to a website that represents the person's work in some way\n         * @type {String}\n         */\n        workUrl: '',\n\n        /**\n         * Work mailing address\n         * @type {object}\n         */\n        workAddress: getMailingAddress(),\n\n        /**\n         * Work phone\n         * @type {String}\n         */\n        workPhone: '',\n\n        /**\n         * Work facsimile\n         * @type {String}\n         */\n        workFax: '',\n\n        /**\n         * vCard version\n         * @type {String}\n         */\n        version: '3.0',\n\n        /**\n         * Get major version of the vCard format\n         * @return {integer}\n         */\n        getMajorVersion: function() {\n            var majorVersionString = this.version ? this.version.split('.')[0] : '4';\n            if (!isNaN(majorVersionString)) {\n                return parseInt(majorVersionString);\n            }\n            return 4;\n        },\n\n        /**\n         * Get formatted vCard\n         * @return {String} Formatted vCard in VCF format\n         */\n        getFormattedString: function() {\n            var vCardFormatter = __webpack_require__(/*! ./lib/vCardFormatter */ \"./node_modules/vcards-js/lib/vCardFormatter.js\");\n            return vCardFormatter.getFormattedString(this);\n        },\n\n        /**\n         * Save formatted vCard to file\n         * @param  {String} filename\n         */\n        saveToFile: function(filename) {\n            var vCardFormatter = __webpack_require__(/*! ./lib/vCardFormatter */ \"./node_modules/vcards-js/lib/vCardFormatter.js\");\n            var contents = vCardFormatter.getFormattedString(this);\n\n            var fs = __webpack_require__(/*! fs */ \"?1216\");\n            fs.writeFileSync(filename, contents, { encoding: 'utf8' });\n        }\n    };\n});\n\nmodule.exports = vCard;\n\n\n//# sourceURL=webpack://demo-vcf/./node_modules/vcards-js/index.js?");

/***/ }),

/***/ "./node_modules/vcards-js/lib/vCardFormatter.js":
/*!******************************************************!*\
  !*** ./node_modules/vcards-js/lib/vCardFormatter.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("/********************************************************************************\n vCards-js, Eric J Nesser, November 2014,\n ********************************************************************************/\n/*jslint node: true */\n\n\n/**\n * vCard formatter for formatting vCards in VCF format\n */\n(function vCardFormatter() {\n\tvar majorVersion = '3';\n\n\t/**\n\t * Encode string\n\t * @param  {String}     value to encode\n\t * @return {String}     encoded string\n\t */\n\tfunction e(value) {\n\t\tif (value) {\n\t\t\tif (typeof(value) !== 'string') {\n\t\t\t\tvalue = '' + value;\n\t\t\t}\n\t\t\treturn value.replace(/\\n/g, '\\\\n').replace(/,/g, '\\\\,').replace(/;/g, '\\\\;');\n\t\t}\n\t\treturn '';\n\t}\n\n\t/**\n\t * Return new line characters\n\t * @return {String} new line characters\n\t */\n\tfunction nl() {\n\t\treturn '\\r\\n';\n\t}\n\n\t/**\n\t * Get formatted photo\n\t * @param  {String} photoType       Photo type (PHOTO, LOGO)\n\t * @param  {String} url             URL to attach photo from\n\t * @param  {String} mediaType       Media-type of photo (JPEG, PNG, GIF)\n\t * @return {String}                 Formatted photo\n\t */\n\tfunction getFormattedPhoto(photoType, url, mediaType, base64) {\n\n\t\tvar params;\n\n\t\tif (majorVersion >= 4) {\n\t\t\tparams = base64 ? ';ENCODING=b;MEDIATYPE=image/' : ';MEDIATYPE=image/';\n\t\t} else if (majorVersion === 3) {\n\t\t\tparams = base64 ? ';ENCODING=b;TYPE=' : ';TYPE=';\n\t\t} else {\n\t\t\tparams = base64 ? ';ENCODING=BASE64;' : ';';\n\t\t}\n\n\t\tvar formattedPhoto = photoType + params + mediaType + ':' + e(url) + nl();\n\t\treturn formattedPhoto;\n\t}\n\n\t/**\n\t * Get formatted address\n\t * @param  {object}         address\n\t * @param  {object}         encoding prefix\n\t * @return {String}         Formatted address\n\t */\n\tfunction getFormattedAddress(encodingPrefix, address) {\n\n\t\tvar formattedAddress = '';\n\n\t\tif (address.details.label ||\n\t\t\taddress.details.street ||\n\t\t\taddress.details.city ||\n\t\t\taddress.details.stateProvince ||\n\t\t\taddress.details.postalCode ||\n\t\t\taddress.details.countryRegion) {\n\n\t\t\tif (majorVersion >= 4) {\n\t\t\t\tformattedAddress = 'ADR' + encodingPrefix + ';TYPE=' + address.type +\n\t\t\t\t\t(address.details.label ? ';LABEL=\"' + e(address.details.label) + '\"' : '') + ':;;' +\n\t\t\t\t\te(address.details.street) + ';' +\n\t\t\t\t\te(address.details.city) + ';' +\n\t\t\t\t\te(address.details.stateProvince) + ';' +\n\t\t\t\t\te(address.details.postalCode) + ';' +\n\t\t\t\t\te(address.details.countryRegion) + nl();\n\t\t\t} else {\n\t\t\t\tif (address.details.label) {\n\t\t\t\t\tformattedAddress = 'LABEL' + encodingPrefix + ';TYPE=' + address.type + ':' + e(address.details.label) + nl();\n\t\t\t\t}\n\t\t\t\tformattedAddress += 'ADR' + encodingPrefix + ';TYPE=' + address.type + ':;;' +\n\t\t\t\t\te(address.details.street) + ';' +\n\t\t\t\t\te(address.details.city) + ';' +\n\t\t\t\t\te(address.details.stateProvince) + ';' +\n\t\t\t\t\te(address.details.postalCode) + ';' +\n\t\t\t\t\te(address.details.countryRegion) + nl();\n\n\t\t\t}\n\t\t}\n\n\t\treturn formattedAddress;\n\t}\n\n\t/**\n\t * Convert date to YYYYMMDD format\n\t * @param  {Date}       date to encode\n\t * @return {String}     encoded date\n\t */\n\tfunction YYYYMMDD(date) {\n\t\treturn date.getFullYear() + ('0' + (date.getMonth()+1)).slice(-2) + ('0' + date.getDate()).slice(-2);\n\t}\n\n\tmodule.exports = {\n\n\t\t/**\n\t\t * Get formatted vCard in VCF format\n\t\t * @param  {object}     vCard object\n\t\t * @return {String}     Formatted vCard in VCF format\n\t\t */\n\t\tgetFormattedString: function(vCard) {\n\n\t\t\tmajorVersion = vCard.getMajorVersion();\n\n\t\t\tvar formattedVCardString = '';\n\t\t\tformattedVCardString += 'BEGIN:VCARD' + nl();\n\t\t\tformattedVCardString += 'VERSION:' + vCard.version + nl();\n\n\t\t\tvar encodingPrefix = majorVersion >= 4 ? '' : ';CHARSET=UTF-8';\n\t\t\tvar formattedName = vCard.formattedName;\n\n\t\t\tif (!formattedName) {\n\t\t\t\tformattedName = '';\n\n\t\t\t\t[vCard.firstName, vCard.middleName, vCard.lastName]\n\t\t\t\t\t.forEach(function(name) {\n\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\tif (formattedName) {\n\t\t\t\t\t\t\t\tformattedName += ' ';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tformattedName += name;\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tformattedVCardString += 'FN' + encodingPrefix + ':' + e(formattedName) + nl();\n\t\t\tformattedVCardString += 'N' + encodingPrefix + ':' +\n\t\t\t\te(vCard.lastName) + ';' +\n\t\t\t\te(vCard.firstName) + ';' +\n\t\t\t\te(vCard.middleName) + ';' +\n\t\t\t\te(vCard.namePrefix) + ';' +\n\t\t\t\te(vCard.nameSuffix) + nl();\n\n\t\t\tif (vCard.nickname && majorVersion >= 3) {\n\t\t\t\tformattedVCardString += 'NICKNAME' + encodingPrefix + ':' + e(vCard.nickname) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.gender) {\n\t\t\t\tformattedVCardString += 'GENDER:' + e(vCard.gender) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.uid) {\n\t\t\t\tformattedVCardString += 'UID' + encodingPrefix + ':' + e(vCard.uid) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.birthday) {\n\t\t\t\tformattedVCardString += 'BDAY:' + YYYYMMDD(vCard.birthday) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.anniversary) {\n\t\t\t\tformattedVCardString += 'ANNIVERSARY:' + YYYYMMDD(vCard.anniversary) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.email) {\n\t\t\t\tif(!Array.isArray(vCard.email)){\n\t\t\t\t\tvCard.email = [vCard.email];\n\t\t\t\t}\n\t\t\t\tvCard.email.forEach(\n\t\t\t\t\tfunction(address) {\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'EMAIL' + encodingPrefix + ';type=HOME:' + e(address) + nl();\n\t\t\t\t\t\t} else if (majorVersion >= 3 && majorVersion < 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'EMAIL' + encodingPrefix + ';type=HOME,INTERNET:' + e(address) + nl();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'EMAIL' + encodingPrefix + ';HOME;INTERNET:' + e(address) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (vCard.workEmail) {\n\t\t\t\tif(!Array.isArray(vCard.workEmail)){\n\t\t\t\t\tvCard.workEmail = [vCard.workEmail];\n\t\t\t\t}\n\t\t\t\tvCard.workEmail.forEach(\n\t\t\t\t\tfunction(address) {\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'EMAIL' + encodingPrefix + ';type=WORK:' + e(address) + nl();\n\t\t\t\t\t\t} else if (majorVersion >= 3 && majorVersion < 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'EMAIL' + encodingPrefix + ';type=WORK,INTERNET:' + e(address) + nl();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'EMAIL' + encodingPrefix + ';WORK;INTERNET:' + e(address) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (vCard.otherEmail) {\n\t\t\t\tif(!Array.isArray(vCard.otherEmail)){\n\t\t\t\t\tvCard.otherEmail = [vCard.otherEmail];\n\t\t\t\t}\n\t\t\t\tvCard.otherEmail.forEach(\n\t\t\t\t\tfunction(address) {\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'EMAIL' + encodingPrefix + ';type=OTHER:' + e(address) + nl();\n\t\t\t\t\t\t} else if (majorVersion >= 3 && majorVersion < 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'EMAIL' + encodingPrefix + ';type=OTHER,INTERNET:' + e(address) + nl();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'EMAIL' + encodingPrefix + ';OTHER;INTERNET:' + e(address) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (vCard.logo.url) {\n\t\t\t\tformattedVCardString += getFormattedPhoto('LOGO', vCard.logo.url, vCard.logo.mediaType, vCard.logo.base64);\n\t\t\t}\n\n\t\t\tif (vCard.photo.url) {\n\t\t\t\tformattedVCardString += getFormattedPhoto('PHOTO', vCard.photo.url, vCard.photo.mediaType, vCard.photo.base64);\n\t\t\t}\n\n\t\t\tif (vCard.cellPhone) {\n\t\t\t\tif(!Array.isArray(vCard.cellPhone)){\n\t\t\t\t\tvCard.cellPhone = [vCard.cellPhone];\n\t\t\t\t}\n\t\t\t\tvCard.cellPhone.forEach(\n\t\t\t\t\tfunction(number){\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;VALUE=uri;TYPE=\"voice,cell\":tel:' + e(number) + nl();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;TYPE=CELL:' + e(number) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (vCard.pagerPhone) {\n\t\t\t\tif(!Array.isArray(vCard.pagerPhone)){\n\t\t\t\t\tvCard.pagerPhone = [vCard.pagerPhone];\n\t\t\t\t}\n\t\t\t\tvCard.pagerPhone.forEach(\n\t\t\t\t\tfunction(number) {\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;VALUE=uri;TYPE=\"pager,cell\":tel:' + e(number) + nl();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;TYPE=PAGER:' + e(number) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (vCard.homePhone) {\n\t\t\t\tif(!Array.isArray(vCard.homePhone)){\n\t\t\t\t\tvCard.homePhone = [vCard.homePhone];\n\t\t\t\t}\n\t\t\t\tvCard.homePhone.forEach(\n\t\t\t\t\tfunction(number) {\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;VALUE=uri;TYPE=\"voice,home\":tel:' + e(number) + nl();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;TYPE=HOME,VOICE:' + e(number) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (vCard.workPhone) {\n\t\t\t\tif(!Array.isArray(vCard.workPhone)){\n\t\t\t\t\tvCard.workPhone = [vCard.workPhone];\n\t\t\t\t}\n\t\t\t\tvCard.workPhone.forEach(\n\t\t\t\t\tfunction(number) {\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;VALUE=uri;TYPE=\"voice,work\":tel:' + e(number) + nl();\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;TYPE=WORK,VOICE:' + e(number) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (vCard.homeFax) {\n\t\t\t\tif(!Array.isArray(vCard.homeFax)){\n\t\t\t\t\tvCard.homeFax = [vCard.homeFax];\n\t\t\t\t}\n\t\t\t\tvCard.homeFax.forEach(\n\t\t\t\t\tfunction(number) {\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;VALUE=uri;TYPE=\"fax,home\":tel:' + e(number) + nl();\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;TYPE=HOME,FAX:' + e(number) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (vCard.workFax) {\n\t\t\t\tif(!Array.isArray(vCard.workFax)){\n\t\t\t\t\tvCard.workFax = [vCard.workFax];\n\t\t\t\t}\n\t\t\t\tvCard.workFax.forEach(\n\t\t\t\t\tfunction(number) {\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;VALUE=uri;TYPE=\"fax,work\":tel:' + e(number) + nl();\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;TYPE=WORK,FAX:' + e(number) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (vCard.otherPhone) {\n\t\t\t\tif(!Array.isArray(vCard.otherPhone)){\n\t\t\t\t\tvCard.otherPhone = [vCard.otherPhone];\n\t\t\t\t}\n\t\t\t\tvCard.otherPhone.forEach(\n\t\t\t\t\tfunction(number) {\n\t\t\t\t\t\tif (majorVersion >= 4) {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;VALUE=uri;TYPE=\"voice,other\":tel:' + e(number) + nl();\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tformattedVCardString += 'TEL;TYPE=OTHER:' + e(number) + nl();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t[{\n\t\t\t\tdetails: vCard.homeAddress,\n\t\t\t\ttype: 'HOME'\n\t\t\t}, {\n\t\t\t\tdetails: vCard.workAddress,\n\t\t\t\ttype: 'WORK'\n\t\t\t}].forEach(\n\t\t\t\tfunction(address) {\n\t\t\t\t\tformattedVCardString += getFormattedAddress(encodingPrefix, address);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (vCard.title) {\n\t\t\t\tformattedVCardString += 'TITLE' + encodingPrefix + ':' + e(vCard.title) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.role) {\n\t\t\t\tformattedVCardString += 'ROLE' + encodingPrefix + ':' + e(vCard.role) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.organization) {\n\t\t\t\tformattedVCardString += 'ORG' + encodingPrefix + ':' + e(vCard.organization) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.url) {\n\t\t\t\tformattedVCardString += 'URL' + encodingPrefix + ':' + e(vCard.url) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.workUrl) {\n\t\t\t\tformattedVCardString += 'URL;type=WORK' + encodingPrefix + ':' + e(vCard.workUrl) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.note) {\n\t\t\t\tformattedVCardString += 'NOTE' + encodingPrefix + ':' + e(vCard.note) + nl();\n\t\t\t}\n\n\t\t\tif (vCard.socialUrls) {\n\t\t\t\tfor (var key in vCard.socialUrls) {\n\t\t\t\t\tif (vCard.socialUrls.hasOwnProperty(key) &&\n\t\t\t\t\t\tvCard.socialUrls[key]) {\n\t\t\t\t\t\tformattedVCardString += 'X-SOCIALPROFILE' + encodingPrefix + ';TYPE=' + key + ':' + e(vCard.socialUrls[key]) + nl();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (vCard.source) {\n\t\t\t\tformattedVCardString += 'SOURCE' + encodingPrefix + ':' + e(vCard.source) + nl();\n\t\t\t}\n\n\t\t\tformattedVCardString += 'REV:' + (new Date()).toISOString() + nl();\n\t\t\t\n\t\t\tif (vCard.isOrganization) {\n\t\t\t\tformattedVCardString += 'X-ABShowAs:COMPANY' + nl();\n\t\t\t} \n\t\t\t\n\t\t\tformattedVCardString += 'END:VCARD' + nl();\n\t\t\treturn formattedVCardString;\n\t\t}\n\t};\n})();\n\n//# sourceURL=webpack://demo-vcf/./node_modules/vcards-js/lib/vCardFormatter.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vcards_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vcards-js */ \"./node_modules/vcards-js/index.js\");\n/* harmony import */ var vcards_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vcards_js__WEBPACK_IMPORTED_MODULE_0__);\n\r\n \r\n//create a new vCard\r\nvar vCard = vcards_js__WEBPACK_IMPORTED_MODULE_0___default()();\r\n \r\n//set properties\r\nvCard.firstName = 'Eric';\r\nvCard.middleName = 'J';\r\nvCard.lastName = 'Nesser';\r\nvCard.organization = 'ACME Corporation';\r\nvCard.photo.attachFromUrl('https://avatars2.githubusercontent.com/u/5659221?v=3&s=460', 'JPEG');\r\nvCard.workPhone = '312-555-1212';\r\nvCard.birthday = new Date(1985, 0, 1);\r\nvCard.title = 'Software Developer';\r\nvCard.url = 'https://github.com/enesser';\r\nvCard.note = 'Notes on Eric';\r\n \r\n//save to file\r\n// vCard.saveToFile('./eric-nesser.vcf');\r\n \r\n//get as formatted string\r\nconsole.log(vCard.getFormattedString());\r\n\r\nconst filename = 'test-contact.vcf';\r\n\r\nconst downloadLink = document.createElement('a');\r\ndownloadLink.setAttribute('href', 'data:text/vcard;charset=utf-8,' + vCard.getFormattedString());\r\ndownloadLink.setAttribute('download', filename);\r\ndownloadLink.innerHTML = filename;\r\ndocument.body.appendChild(downloadLink);\r\n\n\n//# sourceURL=webpack://demo-vcf/./src/index.js?");

/***/ }),

/***/ "?1216":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://demo-vcf/fs_(ignored)?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;